include "math.umi"
include "SDL2.umi"

alias WINDOW_WIDTH = 1000
alias WINDOW_HEIGHT = 800
alias WINDOW_WIDTH_F = Float(WINDOW_WIDTH)
alias WINDOW_HEIGHT_F = Float(WINDOW_HEIGHT)

class Paddle {
    mut SDL_RectF rect
    Int up_scancode
    Int down_scancode
    mut Int score
    Text score_text

    Paddle(Float x, Int up_scancode, Int down_scancode, Int text_pos, Pointer renderer) {
        rect.x = x
        rect.y = WINDOW_HEIGHT_F / 2.0f - HEIGHT / 2.0f
        rect.w = WIDTH
        rect.h = HEIGHT
        this.up_scancode = up_scancode
        this.down_scancode = down_scancode
        score_text = Text(text_pos - 50, 20, "0", renderer)
    }

    static Bool within(Float point, Float left_bound, Float width) {
        left_bound <= point && point <= left_bound + width
    }

    # TODO: fix
    Bool collidingWithBall(SDL_RectF ball_rect) {
        within(ball_rect.x, rect.x, WIDTH) && within(ball_rect.y, rect.y, HEIGHT)
    }

    Void handleKeys(Array[Byte] pressed_keys) {
        mut Float change = 0.0f

        if pressed_keys.get(up_scancode) == 1 { change = change - SPEED }
        if pressed_keys.get(down_scancode) == 1 { change = change + SPEED }

        rect = changeRectF(rect, 0.0f, change, WIDTH, HEIGHT)
    }

    Void increaseScore(Pointer renderer) {
        score = score + 1
        score_text.updateText(score.toString(), renderer)
    }

    Void render(Pointer renderer) {
        score_text.render(renderer)
        handleError(SDL.renderFillRectF(renderer, ref rect))
    }

    alias WIDTH = 20.0f
    alias HEIGHT = 130.0f
    alias PADDING = 30.0f
    alias SPEED = 12.0f
}

class Ball {
    mut SDL_RectF rect
    mut Float velocity_x
    mut Float velocity_y

    Ball() { resetPositionAndVelocity() }

    Void resetPositionAndVelocity() {
        rect = CENTRE
        mut Double angle = random.double() * 2. * PI / 3. - PI / 3.
        if random.int(2) == 1 { angle = angle + PI }
        velocity_x = SPEED * Float(cos(angle))
        velocity_y = SPEED * Float(sin(angle))
    }

    Void move() {
        rect = changeRectF(rect, velocity_x, velocity_y, SIZE, SIZE)
    }

    Void handleHorizontalWallCollision() {
        if rect.y == 0.0f || rect.y == WINDOW_HEIGHT_F - SIZE {
            velocity_y = -velocity_y
        }
    }

    Bool collidingWithLeftWall() { rect.x == 0.0f }
    Bool collidingWithRightWall() { rect.x == WINDOW_WIDTH_F - SIZE }

    Void render(Pointer renderer) {
        handleError(SDL.renderFillRectF(renderer, ref rect))
    }

    alias SIZE = 20.0f
    alias SPEED = 10.0f
    
    static Random random
    static SDL_RectF CENTRE

    static Ball() {
        random = Random()
        CENTRE.x = WINDOW_WIDTH_F / 2.0f - SIZE / 2.0f
        CENTRE.y = CENTRE.x
        CENTRE.w = SIZE
        CENTRE.h = SIZE
    }
}

class Text {
    mut Pointer surface
    mut Pointer texture
    mut SDL_Rect rect

    Text(Int x, Int y, String inital_text, Pointer renderer) {
        rect.x = x
        rect.y = y
        rect.w = 100
        rect.h = 100
        updateText(inital_text, renderer)
    }

    Void updateText(String new_text, Pointer renderer) {
        SDL.freeSurface(surface)
        SDL.destroyTexture(texture)
        surface = TTF.renderTextSolid(FONT, new_text, WHITE)
        texture = SDL.createTextureFromSurface(renderer, surface)
    }

    Void render(Pointer renderer) {
        handleError(SDL.renderCopy(renderer, texture, Pointer.null(), ref rect))
    }

    static Pointer FONT
    static SDL_Color WHITE

    static Text() {
        TTF.init()
        FONT = TTF.openFont("FFF_Forward.ttf", 24)
        WHITE.r = Byte(255)
        WHITE.g = Byte(255)
        WHITE.b = Byte(255)
    }
}

class Sound {
    mut Pointer wav_buffer
    mut UInt wav_length
    mut UInt device_id

    Sound(String file_path) {
        mut SDL_AudioSpec wav_spec = wav_spec
        SDL.loadWAV(file_path, ref wav_spec, ref wav_buffer, ref wav_length)

        mut SDL_AudioSpec _ = _ # want to pass null but can't
        device_id = SDL.openAudioDevice(Pointer.null(), 0, ref wav_spec, ref _, 0)
        SDL.pauseAudioDevice(device_id, 0) # actually unpause it
    }

    Void play() {
        handleError(SDL.queueAudio(device_id, wav_buffer, wav_length))
    }

    Void destroy() {
        SDL.closeAudioDevice(device_id)
        SDL.freeWAV(wav_buffer)
    }
}

# This is an abstract class
class Scene {
    # Update state and return either the same or a new Scene
    Scene nextScene(Array[Byte] pressed_keys, Pointer renderer) { this }
    # Only rendering should be done here
    Void render(Pointer renderer) {}
}

class Court : Scene {
    Paddle left_paddle
    Paddle right_paddle
    Ball ball

    Court(Pointer renderer) {
        left_paddle = Paddle(Paddle.PADDING, SDL.SCANCODE_W, SDL.SCANCODE_S, WINDOW_WIDTH / 4, renderer)
        alias right_paddle_x = WINDOW_WIDTH_F - Paddle.PADDING - Paddle.WIDTH
        right_paddle = Paddle(right_paddle_x, SDL.SCANCODE_UP, SDL.SCANCODE_DOWN, 3 * WINDOW_WIDTH / 4, renderer)
        ball = Ball()
    }

    # Returns true if a player scored 11
    Bool verticalWallCollision(Paddle paddle, Pointer renderer) {
        ball.resetPositionAndVelocity()
        paddle.increaseScore(renderer)
        score_sound.play()
        paddle.score == 11
    }

    # Returns whether to end the game
    Bool handleCollision(Pointer renderer) {
        ball.handleHorizontalWallCollision()

        if ball.collidingWithLeftWall() {
            if verticalWallCollision(right_paddle, renderer) { return true }
        } else if ball.collidingWithRightWall() {
            if verticalWallCollision(left_paddle, renderer) { return true }
        }

        if left_paddle.collidingWithBall(ball.rect) || right_paddle.collidingWithBall(ball.rect) {
            ball.velocity_x = -(ball.velocity_x)
            hit_sound.play()
        }

        false
    }

    Scene nextScene(Array[Byte] pressed_keys, Pointer renderer) {
        left_paddle.handleKeys(pressed_keys)
        right_paddle.handleKeys(pressed_keys)
        ball.move()
        if handleCollision(renderer) { return GameOver(this) }
        this
    }

    Void render(Pointer renderer) {
        drawMiddleLine(renderer)
        left_paddle.render(renderer)
        right_paddle.render(renderer)
        ball.render(renderer)
    }

    static Sound hit_sound
    static Sound score_sound

    static Court() {
        hit_sound = Sound("hit.wav")
        score_sound = Sound("score.wav")
    }
}

class GameOver : Scene {
    Ball ball
    Text left_paddle_text
    Text right_paddle_text

    GameOver(Court court) { 
        ball = court.ball 
        left_paddle_text = court.left_paddle.score_text
        right_paddle_text = court.right_paddle.score_text
    }

    Scene nextScene(Array[Byte] pressed_keys, Pointer _) {
        ball.move()  
        ball.handleHorizontalWallCollision()
        if ball.collidingWithLeftWall() || ball.collidingWithRightWall() {
            ball.velocity_x = -(ball.velocity_x)
        }
        this
    }

    Void render(Pointer renderer) {
        drawMiddleLine(renderer)
        left_paddle_text.render(renderer)
        right_paddle_text.render(renderer)
        ball.render(renderer)
    }
}

Void handleError(Int status) {
    if status < 0 {
        print(SDL.getError())
        exit(status)
    }
}

SDL_RectF changeRectF(SDL_RectF rect, Float change_x, Float change_y, Float obj_width, Float obj_height) {
    rect.x = clamp(rect.x + change_x, 0.0f, WINDOW_WIDTH_F - obj_width)
    rect.y = clamp(rect.y + change_y, 0.0f, WINDOW_HEIGHT_F - obj_height)
    rect
}

Array[Byte] getPressedKeys() {
    mut Int array_size = 0
    Pointer keys_ptr = SDL.getKeyboardState(ref array_size)
    Array[Byte] pressed_keys = Array[Byte](array_size)
    marshalCopy(keys_ptr, pressed_keys, 0, array_size)
    pressed_keys
}

Void drawMiddleLine(Pointer renderer) {
    mut SDL_Rect line = line
    line.x = WINDOW_WIDTH / 2 - 1
    line.y = 3
    line.w = 2
    line.h = 15
    while line.y < WINDOW_HEIGHT {
        Int err = SDL.renderFillRect(renderer, ref line)
        line.y = line.y + 30
    }
}

Void main() {
    if SDL.init(SDL.INIT_VIDEO | SDL.INIT_AUDIO) < 0 {
        print("Video initialisation failed")
        exit(1)
    }

    Pointer window = SDL.createWindow("Pong", SDL.WINDOWPOS_CENTERED, SDL.WINDOWPOS_CENTERED, WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WindowFlags.SHOWN)
    Pointer renderer = SDL.createRenderer(window, -1, SDL_RendererFlags.ACCELERATED)
    mut Scene scene = Court(renderer) 

    mut Bool quit = false
    while !quit {
        mut SDL_Event e = e
        while SDL.pollEvent(ref e) > 0 {
            if e.type == SDL_EventType.QUIT { quit = true }
        }

        scene = scene.nextScene(getPressedKeys(), renderer)

        SDL.setRenderDrawColor(renderer, Byte(0), Byte(0), Byte(0), Byte(255))
        SDL.renderClear(renderer)

        # everything except background is white
        SDL.setRenderDrawColor(renderer, Byte(255), Byte(255), Byte(255), Byte(255))
        scene.render(renderer)
        SDL.renderPresent(renderer)

        SDL.delay(UInt(1000 / 60))
    }

    SDL.destroyRenderer(renderer)
    SDL.destroyWindow(window)
    TTF.quit()
    SDL.quit()
}
