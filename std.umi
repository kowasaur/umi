# This is the standard library, included by default in all umi programs

il class Void "void" {}
il class Bool "bool" {}

il class Int "int32" {
    il Int(String) "call int32 int32::Parse(string)"
    il String toString() "call string class [mscorlib]System.Convert::ToString(int32)"
}

il class Char "char" {
    # `this` is the separator like in Python
    il String join(Array[String]) "call string string::Join(char, string[])"
}

il class String "string" {
    ilf Char get(Int) "get_Chars"

    # start_index, length
    ilf String substring(Int, Int) "Substring"
    ilf String substring(Int) "Substring"

    ilf String lowercase() "ToLower"
    ilf String uppercase() "ToUpper"

    # `this` is the separator like in Python
    il String join(Array[String]) "call string string::Join(string, string[])"
}

il class Array[T] "{0}[]" {
    il Array[T](Int) "newarr {0}"
    il T get(Int) "ldelem {0}"
    il Void set(Int, T) "stelem {0}"
    il Int size() "ldlen"
}

il class List[T] "class [mscorlib]System.Collections.Generic.List`1<{0}>" {
    # TODO: fix generics of constructors so ilf can be used instead
    il List[T]() "newobj void class [mscorlib]System.Collections.Generic.List`1<{0}>::.ctor()"
    ilf T get(Int) "get_Item"
    ilf Void set(Int, T) "set_Item"
    ilf Int size() "get_Count"
    ilf Void add(T) "Add"
}

il class Dict[K, V] "class [mscorlib]System.Collections.Generic.Dictionary`2<{0}, {1}>" {
    il Dict[K, V]() "newobj void class [mscorlib]System.Collections.Generic.Dictionary`2<{0}, {1}>::.ctor()"
    ilf V get(K) "get_Item"
    ilf Void set(K, V) "set_Item"
}

il class Console "[mscorlib]System.Console" {
    ilf static Void write(String) "Write"
    ilf static Void write(Int) "Write"
    ilf static Void write(Char) "Write"
}

il class File "[mscorlib]System.IO.File" {
    ilf static String read(String) "ReadAllText"
    ilf static Array[String] readLines(String) "ReadAllLines"
}

ilf Void print(String) "[mscorlib]System.Console::WriteLine"
ilf Void print(Char) "[mscorlib]System.Console::WriteLine"
ilf Void print(Int) "[mscorlib]System.Console::WriteLine"
ilf Void print(Bool) "[mscorlib]System.Console::WriteLine"

# TODO: somehow make this generic
Void print(Array[String] array) {
    if array.size() == 0 { print("[]") }
    else { print("[\"" + "\", \"".join(array) + "\"]") }
}

ilf String input() "[mscorlib]System.Console::ReadLine"
# TODO: Maybe add inline functions
String input(String prompt) {
    Console.write(prompt)
    input()
}

ilf Void exit(Int) "[mscorlib]System.Environment::Exit"

# Arithmetic Operators
il Int +(Int, Int) "add"
il Int -(Int, Int) "sub"
il Int *(Int, Int) "mul"
il Int /(Int, Int) "div"
il Int %(Int, Int) "rem"
il Int -(Void, Int) "neg"

# Comparison Operators
ilf Bool ==(String, String) "string::op_Equality"
il Bool ==(Bool, Bool) "ceq"
il Bool ==(Int, Int) "ceq"
ilf Bool !=(String, String) "string::op_Inequality"
Bool !=(Bool a, Bool b) { (a == b) == false }
Bool !=(Int a, Int b) { (a == b) == false }
il Bool >(Int, Int) "cgt"
il Bool <(Int, Int) "clt"
Bool >=(Int a, Int b) { !(a < b) }
Bool <=(Int a, Int b) { !(a > b) }

# Logical Operators
il Bool &&(Bool, Bool) "and"
il Bool ||(Bool, Bool) "or"
Bool !(Void _, Bool a) { a == false }

# Bitwise Operators
il Int <<(Int, Int) "shl"
il Int >>(Int, Int) "shr"
il Int &(Int, Int) "and"
il Int |(Int, Int) "or"

ilf String +(String, String) "string::Concat"

# TODO: put these in String (requires letting non-il in il classes)
# the Int is actually an enum but Umi does not have enums yet
il Array[String] split(String, Char, Int) "call instance string[] string::Split(char, valuetype [mscorlib]System.StringSplitOptions)"
Array[String] split(String string, Char separator) { split(string, separator, 0) }
il Array[String] split(String, String, Int) "call instance string[] string::Split(string, valuetype [mscorlib]System.StringSplitOptions)"
Array[String] split(String string, String separator) { split(string, separator, 0) }

# Create a range of integers from `low` to `high` (both inclusive)
Array[Int] ...(Int low, Int high) {
    Array[Int] range = Array[Int](high - low + 1)
    mut Int i = 0
    while i < high {
        range.set(i, low + i)
        i = i + 1
    }
    range
}
